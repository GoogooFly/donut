# 正则表达式

正则表达式是国际标准,跨越语言

正则表达式是一个规则,用于验证字符串

## 基础

1. 字面量匹配

规则中直接书写字面量字符

2. 特殊字符

```js

· 表示匹配任何字符 除换行符外  \n

^ 表示匹配以字符串开始

$ 表示字以字符串结束

```

3. 转义符

```js

\n  换行符

\r  回车符

\t  匹配制表符

\s  空白字符  任何空白字符都可以

\S  除了空白字符之外的所有空白字符都可以

\b  匹配一个单词的边界 

\B  非单词边界


\d  匹配一个数字字符 等价于[0-9]

\D  非数字

\w  匹配字母、数字、下划线

\u  匹配字符编码
```

转义符可以将特殊字符转义

4. 字符集

```js

[字符范围]

[1-9] 范围 1到9

匹配中文 /[\u4e00-\u9fa5]/g;

[^字符范围] 对字符范围取反

```

5. 量词

前面的规则出现的次数

```js

* 匹配0次或多次

+ 匹配一个或多个    

? 匹配一个或0个

{} 自己写数字  eg: {n} 匹配n个  {n,} 匹配>=n个 {n,m} 匹配n到m个

```

6. 或者

```js

多个规则之间,使用或者```|```,表示多个规则,任选其一 
  
() 优先级

```

## JS中的应用

JS中,正则表达式表现为一个对象,该对象是通过构造函数RegExp

### 创建正则对象

1. 字面量模式

```js

let reg = /正则表达式/gmi; 

// g: 全局搜索 表示 搜索全部达到表达式的值
// 如果没有全局搜索 只会输出一个达到表达式的值

// i: 忽略大小写

// m: 多行匹配
```
2. 构造函数模式

```js

let reg = new RegExp("正则表达式","gi");

```

### 正则实例成员

- global  是否开启全局匹配
- ignoreCase  在匹配字符串时是否要忽略字符的大小写
- multiline  是否开启多行模式匹配(影响^和$的行为)
- source  得到目前正则表达式的规则
- test  验证某个字符串是否满足规则 
- exec  execute 执行匹配得到匹配结果 匹配不到返回null
```js

// 得到所有的匹配结果和位置

let a = /\d+/g; 

let s = "123asd456";

 while(true){
     let result = a.exec(s);
     if(!result){
         break;
     }
     return `结果 ${result[0]},位置 ${result.index}`
 }

```


> 正则表达式,默认情况下,适用贪婪模式
> 在量词后,加上? 表示进入非贪婪模式(一次验证一个字符串)

### 字符串对象中的正则

- match  使用正则表达式与字符串相比较

```js

let a = "123asd456asdwqe"; // 字符串

let s = a.match(/\d+/g); // 正则规则

console.log(a,s);
// s 显示 比较正则规则过后的a    （数组）

```

- search 对正则表达式和指定字符串进行匹配搜索,返回第一个出现的匹配项的下标

```js

    let a = "123asd456asdwqe"; // 字符串

    let search = a.search(/\d+/g); // 正则规则

    console.log(a,search);

```

- split 通过 分离字符 串成 字串 ,将字符串对象分割成字符串数组

```js
    let a = "123,asd45,6as,dwqe";

    let split = a.split(/[,]/); // 用逗号进行分割

    let splits = a.split(/[,]/,3); // 后面的3是第二个参数 表示从前往后 分割三次

    console.log(split);

```

- replace 被用来在正则表达式和字符串直接比较,然后用新的字符串来替换被匹配的子串

```js

    let a = "12 3asd 456a sdw qe"; // 字符串

    let result = a.replace(/\s/g,","); // 第一个值放正则规则 第二个值放替换的内容（第二个值可以放函数）

    // 把字符串内的空格 替换成,

    console.log(result);

```

## 进阶

### 捕获组

用小括号包裹的部分叫做捕获组,捕获组会出现在匹配结果中

捕获组可以命名,叫做具名捕获组 $n 表示第n个捕获组 

非捕获组 ?:

```js

    let s = /^(?<year>\d{4})\-(?<month>\d{2})\-(?<date>\d{2})$/g;
    // 给小括号内?<> 可以命名

    let s = /^(?:\d{4})$/g; //非捕获组 ?:

    let a = "2002-06-19";
    let str = "";
    while(result = s.exec(a)){
        console.log(result[0],result[1],result[2],result[3]);
        console.log(result.groups.year); // 输出 groups对象里的year
    }

```

### 反向引用

在正则表达式中,使用某个捕获组,```\捕获组编号```

```js
// 找出该字符串中连续出现的字符

let s = "aaaaabbbbbbbccccdf"; 

let reg = /(\w)\1+/g; // \1 重复上一次的正则规则 字符串也要一致

let reg = /(?<char>\w)\k<char>+/g; // \k<> 使用捕获组的名字 进行引用

while(result = reg.exec(s)){
    console.log(result[1]);
}

```

### 正向断言(预查)

检查某个字符后面的字符是否满足某个规则,该规则不成为匹配结果,并且不成为捕获组

```js
// 查询后面是数组的字母

let s = "asd121qwe786dfss456";

let reg = /[a-zA-Z](?=\d+)/g; // ?= 正向预查

```

```js
// 每隔三位加一个,

let s = "4567894";

let reg = /\B(?=(\d{3})+$)/g;

// \B 非单词边界  当字符串正好为3的倍数时 取消最前面添加的,

// (?=(\d{3})+$)  检查字符串 是否为3的倍数 是否在结尾
s = s.replace(reg,",");

console.log(s);

```
### 负向断言(预查)

检查某个字符后面的字符是否不满足某个规则,该规则不成为匹配结果,并且不成为捕获组

```js
// 判断密码强度
// 要求密码中必须出现小写字母、大写字母、数字、特殊字符(!@#_,.),6-12位

let s = "asd132Asad._=";
let reg = /^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[!@#_,.]).{6,12}$/;
// 正向预查 匹配0次或多次的所有a-z A-Z 所有数字 特殊字符
// 预查后如果都满足要求 则 进行判断位数 是否位6,12位

```

```js
// 判断密码强度
// 密码长度必须是6-12位
// 出现小写字母、大写字母、数字、特殊字符(!@#_,.) --> 强
// 出现小写字母、大写字母、数字 --> 中
// 出现小写字母、大写字母 --> 弱

function judgePwd(pwd){
    if(/^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[!@#_,.]).{6,12}$/.test(pwd)){
        return "强";
    }else if(/^(?=.*[a-z])(?=.*[A-Z])(?=.*\d).{6,12}$/.test(pwd)){
        return "中";
    }else if(/^(?=.*[a-z])(?=.*[A-Z]).{6,12}$/.test(pwd)){
        return "弱";
    }else{
        return "不满足要求";
    }
}
console.log(judgePwd("123asd456"));
  
```